/*
 * oscillators.c
 *
 *  Created on: Dec 26, 2020
 *      Author: fil
 */


#include "main.h"
#include "math.h"
#include "arm_math.h"


OscillatorsTypeDef	Oscillator[CHANNELS][NUMOSCILLATORS];
float	PI_180	= 	M_PI/180.0f;
float	PI2		= 	M_PI*2;
float	DcAdjust = 	2048.0f;

uint32_t	sintab[360] =
{
		0x800,0x823,0x847,0x86b,0x88e,0x8b2,0x8d6,0x8f9,
		0x91c,0x940,0x963,0x986,0x9a9,0x9cc,0x9ef,0xa11,
		0xa34,0xa56,0xa78,0xa9a,0xabc,0xadd,0xaff,0xb20,
		0xb40,0xb61,0xb81,0xba1,0xbc1,0xbe0,0xbff,0xc1e,
		0xc3d,0xc5b,0xc78,0xc96,0xcb3,0xcd0,0xcec,0xd08,
		0xd24,0xd3f,0xd5a,0xd74,0xd8e,0xda7,0xdc0,0xdd9,
		0xdf1,0xe09,0xe20,0xe37,0xe4d,0xe63,0xe78,0xe8d,
		0xea1,0xeb5,0xec8,0xedb,0xeed,0xefe,0xf0f,0xf20,
		0xf30,0xf3f,0xf4e,0xf5c,0xf6a,0xf77,0xf84,0xf8f,
		0xf9b,0xfa6,0xfb0,0xfb9,0xfc2,0xfcb,0xfd2,0xfd9,
		0xfe0,0xfe6,0xfeb,0xff0,0xff4,0xff7,0xffa,0xffc,
		0xffe,0xfff,0xfff,0xfff,0xffe,0xffc,0xffa,0xff7,
		0xff4,0xff0,0xfeb,0xfe6,0xfe0,0xfd9,0xfd2,0xfcb,
		0xfc2,0xfb9,0xfb0,0xfa6,0xf9b,0xf8f,0xf84,0xf77,
		0xf6a,0xf5c,0xf4e,0xf3f,0xf30,0xf20,0xf0f,0xefe,
		0xeed,0xedb,0xec8,0xeb5,0xea1,0xe8d,0xe78,0xe63,
		0xe4d,0xe37,0xe20,0xe09,0xdf1,0xdd9,0xdc0,0xda7,
		0xd8e,0xd74,0xd5a,0xd3f,0xd24,0xd08,0xcec,0xcd0,
		0xcb3,0xc96,0xc78,0xc5b,0xc3d,0xc1e,0xbff,0xbe0,
		0xbc1,0xba1,0xb81,0xb61,0xb40,0xb20,0xaff,0xadd,
		0xabc,0xa9a,0xa78,0xa56,0xa34,0xa11,0x9ef,0x9cc,
		0x9a9,0x986,0x963,0x940,0x91c,0x8f9,0x8d6,0x8b2,
		0x88e,0x86b,0x847,0x823,0x800,0x7dc,0x7b8,0x794,
		0x771,0x74d,0x729,0x706,0x6e3,0x6bf,0x69c,0x679,
		0x656,0x633,0x610,0x5ee,0x5cb,0x5a9,0x587,0x565,
		0x543,0x522,0x500,0x4df,0x4bf,0x49e,0x47e,0x45e,
		0x43e,0x41f,0x400,0x3e1,0x3c2,0x3a4,0x387,0x369,
		0x34c,0x32f,0x313,0x2f7,0x2db,0x2c0,0x2a5,0x28b,
		0x271,0x258,0x23f,0x226,0x20e,0x1f6,0x1df,0x1c8,
		0x1b2,0x19c,0x187,0x172,0x15e,0x14a,0x137,0x124,
		0x112,0x101,0xf0,0xdf,0xcf,0xc0,0xb1,0xa3,
		0x95,0x88,0x7b,0x70,0x64,0x59,0x4f,0x46,
		0x3d,0x34,0x2d,0x26,0x1f,0x19,0x14,0xf,
		0xb,0x8,0x5,0x3,0x1,0x0,0x0,0x0,
		0x1,0x3,0x5,0x8,0xb,0xf,0x14,0x19,
		0x1f,0x26,0x2d,0x34,0x3d,0x46,0x4f,0x59,
		0x64,0x70,0x7b,0x88,0x95,0xa3,0xb1,0xc0,
		0xcf,0xdf,0xf0,0x101,0x112,0x124,0x137,0x14a,
		0x15e,0x172,0x187,0x19c,0x1b2,0x1c8,0x1df,0x1f6,
		0x20e,0x226,0x23f,0x258,0x271,0x28b,0x2a5,0x2c0,
		0x2db,0x2f7,0x313,0x32f,0x34c,0x369,0x387,0x3a4,
		0x3c2,0x3e1,0x400,0x41f,0x43e,0x45e,0x47e,0x49e,
		0x4bf,0x4df,0x500,0x522,0x543,0x565,0x587,0x5a9,
		0x5cb,0x5ee,0x610,0x633,0x656,0x679,0x69c,0x6bf,
		0x6e3,0x706,0x729,0x74d,0x771,0x794,0x7b8,0x7dc,
};

uint32_t uint32_t_sinFunc(uint32_t pos)
{
	if ( pos > 360 )
		pos = 360;
	return sintab[pos];
}

float sinFuncCalc(float pos)
{
  return arm_sin_f32(pos*2*M_PI);
}

float sawFunc(float pos)
{
  return pos*2-1;
}

float triangleFunc(float pos)
{
  return 1-fabs(pos-0.5)*4;
}

float squareFunc(float pos)
{
	return pos >= 0.5f ? 0.0f : 1.0f;
}

static	void static_process_oscillator(uint32_t channel,uint32_t osc_number)
{
uint16_t	i,start,end;
uint32_t	uint32_t_pos;
float pos;

	get_limits(&start,&end,(uint32_t *)Oscillator[channel][osc_number].buffer_flag_ptr);
	for ( i=start;i<end;i++)
	{
		pos = Oscillator[channel][osc_number].current_phase / 360.0f;
		uint32_t_pos = Oscillator[channel][osc_number].current_phase_uint32_t;
		switch (Oscillator[channel][osc_number].waveform)
		{
			//case	SINE	:	osc_buf[channel][osc_number][i] = (uint32_t )((sinFunc(pos)* DcAdjust)+ DcAdjust); break;
			case	SINE	:	osc_buf[channel][osc_number][i] = uint32_t_sinFunc(uint32_t_pos); break;
			/*
			case	TRIANGLE:	osc_buf[channel][osc_number][i] = (uint32_t )((triangleFunc(pos)* DcAdjust)+ DcAdjust); break;
			case	SAW		:	osc_buf[channel][osc_number][i] = (uint32_t )((sawFunc(pos)* DcAdjust)+ DcAdjust); break;
			case	SQUARE	:	osc_buf[channel][osc_number][i] = (uint32_t )((squareFunc(pos)* DcAdjust)+ DcAdjust); break;
			*/
		}
		//Oscillator[channel][osc_number].current_phase += Oscillator[channel][osc_number].delta_phase;
		Oscillator[channel][osc_number].current_phase_uint32_t += Oscillator[channel][osc_number].delta_phase_uint32_t;
		/*
		if ( Oscillator[channel][osc_number].current_phase > 360.0f )
		{
			if ( Oscillator[channel][osc_number].new_freq != 0 ) // Hard sync
			{
				Oscillator[channel][osc_number].freq = Oscillator[channel][osc_number].new_freq;
				Oscillator[channel][osc_number].new_freq = 0;
				Oscillator[channel][osc_number].delta_phase = 360.0f / ((float )SystemParameters.sampling_frequency[channel] / Oscillator[channel][osc_number].freq);

			}
			Oscillator[channel][osc_number].current_phase -= 360.0f;
		}
		*/
		if ( Oscillator[channel][osc_number].current_phase_uint32_t >= 360 )
			Oscillator[channel][osc_number].current_phase_uint32_t -= 360;
	}
}

void DoOscillators(void)
{
uint16_t	osc_number,channel;
	for(channel=0;channel<CHANNELS;channel++)
	{
		for(osc_number=0;osc_number<NUMOSCILLATORS;osc_number++)
		{
			if ( Oscillator[channel][osc_number].enabled == OSCILLATOR_ENABLED )
				static_process_oscillator(channel,osc_number);
		}
	}
}

uint32_t EnableOscillator(uint32_t channel,uint32_t osc_number)
{
	Oscillator[channel][osc_number].enabled = OSCILLATOR_ENABLED;
	return ((osc_number+1) & (NUMOSCILLATORS-1));
}

void DisableOscillator(uint32_t channel)
{
uint32_t	i;
	for(i=0;i<NUMOSCILLATORS;i++)
		Oscillator[channel][i].enabled = OSCILLATOR_DISABLED;
}

void ChangeOscillatorFrequency(uint32_t channel,uint32_t osc_number, uint32_t freq)
{
	if ( Oscillator[channel][osc_number].enabled == OSCILLATOR_ENABLED )
		Oscillator[channel][osc_number].new_freq = (float )freq;
	else
		Oscillator[channel][osc_number].freq = (float )freq;
}

void ChangeOscillatorWaveform(uint32_t channel,uint32_t osc_number, uint32_t waveform)
{
	Oscillator[channel][osc_number].waveform = waveform;
}

void ChangeOscillatorPitchBend(uint32_t channel,uint32_t osc_number, uint32_t percent)
{
	Oscillator[channel][osc_number].new_freq = Oscillator[channel][osc_number].freq + ((Oscillator[channel][osc_number].freq/100.0f)* (float )percent);
}

uint32_t InitOscillator(uint32_t osc_number,uint32_t freq, uint32_t channel, uint32_t waveform)
{
	if ( osc_number > NUMOSCILLATORS-1 )
		return 1;
	Oscillator[channel][osc_number].enabled = OSCILLATOR_DISABLED;
	Oscillator[channel][osc_number].freq = (float )freq;
	Oscillator[channel][osc_number].waveform = waveform;
	Oscillator[channel][osc_number].current_phase = 0.0f;
	Oscillator[channel][osc_number].buffer_flag_ptr = get_bufferhalf(channel);
	Oscillator[channel][osc_number].delta_phase = 360.0f / ((float )SystemParameters.sampling_frequency[channel] / Oscillator[channel][osc_number].freq);
	Oscillator[channel][osc_number].current_phase_uint32_t = 0;
	Oscillator[channel][osc_number].delta_phase_uint32_t = (uint32_t )Oscillator[channel][osc_number].delta_phase;
	return osc_number;
}
